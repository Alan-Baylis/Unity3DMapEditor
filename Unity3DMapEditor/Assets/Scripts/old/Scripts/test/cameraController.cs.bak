using UnityEngine; using System.Collections; public class cameraController : MonoBehaviour {  	public Transform targetTransform; 	public float     pitch 				= 60; 	public float 	 rotateSpeed 	  	= 2.0f; 	public float     mouseWheelSpeed  	= 8.0f; 	public float     pivotDistance    	= 8; 	public float     maxPivotDistance 	= 10; 	public float     minPivotDistance 	= 2; 	private bool     isRotateCamera 	= false; 	private Vector3  targetLastPosition	= Vector3.zero;     public  Vector3  shakeMount = new Vector3(1, 1, 1);     public  float    duration = 0;     public float     leftTime = 0;     const int RAND_MAX = 0x7fff;     Vector3 Scale = new Vector3(1, 1, 1);     Quaternion      mShakeRotation  = new Quaternion();     System.Random   mShakeRand      = new System.Random(); 	 	// Use this for initialization 	void Start ()  	{ 		Camera.main.transform.position = new Vector3(targetTransform.root.position.x - pivotDistance * Mathf.Cos(Mathf.Deg2Rad*pitch), 		                                             targetTransform.root.position.y + pivotDistance * Mathf.Sin(Mathf.Deg2Rad*pitch), 		                                             targetTransform.root.position.z - pivotDistance * Mathf.Cos(Mathf.Deg2Rad*pitch)); 		 		Vector3 relPos = targetTransform.root.position - Camera.main.transform.position; 		Camera.main.transform.rotation = Quaternion.LookRotation(relPos); 		targetLastPosition = targetTransform.root.position; 	} 	 	// Update is called once per frame 	void LateUpdate () 	{ 		//rotate camera
        if (leftTime > 0)
        {
            Camera.main.transform.localPosition = mShakeRand.Next() * shakeMount;
            //  Vector3 amt = shakeMount * (leftTime / duration);
            // float yaw = (((float)(mShakeRand.Next()) / RAND_MAX) - 0.5f) * amt.x;
            //  float pitch = (((float)(mShakeRand.Next()) / RAND_MAX) - 0.5f) * amt.y;
            //  float roll = (((float)(mShakeRand.Next()) / RAND_MAX) - 0.5f) * amt.z;
            //  mShakeRotation.eulerAngles = new Vector3(pitch, yaw, roll);
            leftTime -= UnityEngine.Time.deltaTime;
            //  Matrix4x4 cameraWorld = Matrix4x4.TRS(Vector3.zero, mShakeRotation, Scale);
            //   Camera.main.transform.forward = cameraWorld.MultiplyPoint(Camera.main.transform.forward);
        }
        else
        {
            Camera.main.transform.localPosition = Vector3.zero;
        }          if(Input.GetMouseButtonDown(1)) 		{ 			isRotateCamera = true; 		} 		 		if(isRotateCamera) 		{ 			float h = rotateSpeed * Input.GetAxis ("Mouse X"); 			float v = rotateSpeed * Input.GetAxis ("Mouse Y"); 			float speed; 			if(Mathf.Abs(h) > Mathf.Abs(v)) 			{ 				speed = h; 			} 			else 			{ 				speed = v; 			} 			Camera.main.transform.RotateAround(targetTransform.root.position,Vector3.up,speed); 			Vector3 relPos = targetTransform.root.position - Camera.main.transform.position; 			Camera.main.transform.rotation = Quaternion.LookRotation(relPos); 		} 		 		if(Input.GetMouseButtonUp(1)) 		{ 			isRotateCamera = false;	 		} 		 		//scale camera 		float scrollDelta = Input.GetAxis("Mouse ScrollWheel"); 		if(scrollDelta!=0) 		{ 			scrollDelta = scrollDelta * mouseWheelSpeed; 			Vector3 faceTargetDir = targetTransform.root.position - Camera.main.transform.position; 			float distance = faceTargetDir.magnitude - scrollDelta; 			if(distance > maxPivotDistance) 			{ 				distance = maxPivotDistance; 				 			} 			else if(distance < minPivotDistance) 			{ 				distance = minPivotDistance; 			} 			faceTargetDir.Normalize(); 			Camera.main.transform.position = targetTransform.root.position  - faceTargetDir*distance;  		} 			 		//translate camera 		Vector3 step = targetTransform.root.position - targetLastPosition; 		Camera.main.transform.position += step; 		targetLastPosition = targetTransform.root.position;           		 	} 	 	void FixedUpdate() 	{ 		 	} } 